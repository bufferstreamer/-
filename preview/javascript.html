<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="javascript">JavaScript</h1>
<p>基本同java</p>
<p>JavaScript的实现包括以下3个部分：</p>
<table>
<thead>
<tr>
<th><a href="https://so.csdn.net/so/search?q=ECMAScript&amp;spm=1001.2101.3001.7020">ECMAScript</a>(核心)</th>
<th>描述了JS的语法和基本对象。</th>
</tr>
</thead>
<tbody>
<tr>
<td>文档对象模型 （DOM）</td>
<td>处理网页内容的方法和接口</td>
</tr>
<tr>
<td>浏览器对象模型（BOM）</td>
<td>与浏览器交互的方法和接口</td>
</tr>
</tbody>
</table>
<p>DOM 是为了操作文档出现的 API，document 是其的一个对象；
        BOM 是为了操作浏览器出现的 API，window 是其的一个对象。</p>
<p>BOM是浏览器对象模型，DOM是<a href="https://www.baidu.com/s?wd=文档对象模型&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHcvrjTdrH00T1Y4mvn3mWKWmWT4nW99myRv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHTvPH6Ln1DzPH0snWR1P1fvn0">文档对象模型</a>，前者是对浏览器本身进行操作，而后者是对浏览器（可看成容器）内的内容进行操作</p>
<h2 id="-">规则</h2>
<p>var定义变量，该变量为全局作用域，重复定义时会覆盖前面的变量</p>
<p>let定义变量，改变量为局部作用域，重复定义会报错</p>
<p>const定义静态变量，当定义的是基本类型时，该变量无法被改变。当定义的是引用类型的时候，该变量只是指向该对象的地址，对象内部的数据可以被改变。当对象内部不想被改变时，可以使用Object.freeze（对象名）来冻结</p>
<p>用{}来表示一个对象</p>
<p>引用类型默认值为null </p>
<p>基本类型默认值为undefined  当函数和形参没有被定义的时候也会返回undefined</p>
<p>for in 遍历的是键</p>
<p>for of 遍历的是值</p>
<p><code></code>可以在字符串拼接时起到很好的作用</p>
<p>如<img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220218135223470.png" alt="image-20220218135223470" style="zoom:50%;" /></p>
<h3 id="-">...语法</h3>
<p>可以使数量不定得多个元素变得可以用一个变量来接受</p>
<h4 id="-">聚合</h4>
<p>...在等号左边时相当于聚合功能</p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225155701726.png" alt="image-20220225155701726"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225155718455.png" alt="image-20220225155718455"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225155740405.png" alt="image-20220225155740405"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225155757605.png" alt="image-20220225155757605"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225160340169.png" alt="image-20220225160340169"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225160406153.png" alt="image-20220225160406153"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225160655184.png" alt="image-20220225160655184"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225160707565.png" alt="image-20220225160707565"></p>
<h4 id="-">分散</h4>
<p>...在等号右边时相当于分散功能</p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225161534186.png" alt="image-20220225161534186"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220225161555098.png" alt="image-20220225161555098"></p>
<h3 id="-">比较和转换</h3>
<p>数组或者对象在转换为布尔类型时会被转换为真</p>
<p>但是在与布尔类型比较时，内部有一个元素会转换为真，没有元素会转换为假，多个元素会转换为NaN</p>
<h2 id="-">函数</h2>
<p>定义：var 函数名 = function （）{}</p>
<pre><code>        或者  function 函数名 （）{}
</code></pre><p>其中函数参数定义个数和实际传入的参数个数可以不相等，js提供了一个关键字arguments数组来获取形参个数。还引入了rest来表示<img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220115145920259.png" alt="image-20220115145920259" style="zoom:67%;" /></p>
<h2 id="-">字符串</h2>
<p>String.length</p>
<p>String.toUpperCase()    转为大写</p>
<p>String.toLowerCase()    转为小写</p>
<p>String.trim()    删除空白</p>
<h3 id="-">字符串截取函数</h3>
<p>String.slice(number start,number end)     start为负数时，从后往前截取</p>
<p>String.sbustring(number start,number end)    start为负数时，视为0</p>
<p>String.substr(number start,number mount)    start为负数时，从后往前截取</p>
<h3 id="-">字符串检索</h3>
<p>String.indexOf(string character,number start_location)    找不到返回-1 </p>
<p>String.lastIndexOf(string character,number start_location)    找不到返回-1  从右侧开始查</p>
<p>String.includes(string character,number start_location)    找不到返回FALSE</p>
<p>String.startsWith(string character)</p>
<p>String.endsWith(string character)</p>
<h3 id="-">字符串分割</h3>
<h4 id="split">split</h4>
<p><code>split</code> 方法用于将字符串分割成数组，类似<code>join</code>方法的反函数。</p>
<pre><code class="lang-javascript">let price = &quot;99,78,68&quot;;
console.log(price.split(&quot;,&quot;)); //[&quot;99&quot;, &quot;78&quot;, &quot;68&quot;]
</code></pre>
<p>####</p>
<h2 id="-">数组</h2>
<h3 id="-">管理元素</h3>
<h4 id="push-unshift">push和unshift</h4>
<p>push从数组后面添加元素</p>
<p>unshift从数组前面添加元素</p>
<h4 id="pop-shift">pop和shift</h4>
<p>pop从数组后面弹出元素</p>
<p>shift从数组前面弹出元素</p>
<h4 id="fill">fill</h4>
<p>给数组填充元素</p>
<p>Array.fill(&quot;填充得内容&quot;，开始位置，结束位置)</p>
<h4 id="slice-splice">slice和splice</h4>
<p>Array.slice(开始位置，结束位置)返回原数组被截断的数组，不改变原数组</p>
<p>Array.splice(开始位置，截取个数，替换的元素)原数组被改变</p>
<h4 id="-">清空数组</h4>
<p>将数组值修改为<code>[]</code>可以清空数组，如果有多个引用时数组在内存中存在被其他变量引用。</p>
<pre><code class="lang-javascript">let user = [{ name: &quot;hdcms&quot; }, { name: &quot;后盾人&quot; }];
let cms = user;
user = [];
console.log(user);
console.log(cms);
</code></pre>
<p>将数组<code>length</code>设置为0也可以清空数组</p>
<pre><code class="lang-javascript">let user = [{ name: &quot;hdcms&quot; }, { name: &quot;后盾人&quot; }];
user.length = 0;
console.log(user);
</code></pre>
<p>使用<code>splice</code>方法删除所有数组元素</p>
<pre><code class="lang-javascript">let user = [{ name: &quot;hdcms&quot; }, { name: &quot;后盾人&quot; }];
user.splice(0, user.length);
console.log(user);
</code></pre>
<p>使用<code>pop/shift</code>删除所有元素，来清空数组</p>
<pre><code class="lang-javascript">let user = [{ name: &quot;hdcms&quot; }, { name: &quot;后盾人&quot; }];
while (user.pop()) {}
console.log(user);
</code></pre>
<h3 id="-">合并拆分</h3>
<h4 id="join">join</h4>
<p>Array.join(&quot;连接得符号&quot;) 将数组各个元素以指定得符号进行连接，返回一个连接后得字符串</p>
<h4 id="concat">concat</h4>
<p><code>concat</code>方法用于连接两个或多个数组，元素是值类型的是复制操作，如果是引用类型还是指向同一对象</p>
<pre><code class="lang-javascript">let array = [&quot;hdcms&quot;, &quot;houdunren&quot;];
let hd = [1, 2];
let cms = [3, 4];
console.log(array.concat(hd, cms)); //[&quot;hdcms&quot;, &quot;houdunren&quot;, 1, 2, 3, 4]
</code></pre>
<p>也可以使用扩展语法实现连接</p>
<pre><code class="lang-javascript">console.log([...array, ...hd, ...cms]);
</code></pre>
<h4 id="copywithin">copyWithin</h4>
<p>使用 <code>copyWithin</code> 从数组中复制一部分到同数组中的另外位置。</p>
<p>语法说明</p>
<pre><code class="lang-javascript">array.copyWithin(target, start, end)
</code></pre>
<p>参数说明</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><em>target</em></td>
<td style="text-align:left">必需。复制到指定目标索引位置。</td>
</tr>
<tr>
<td style="text-align:left"><em>start</em></td>
<td style="text-align:left">可选。元素复制的起始位置。</td>
</tr>
<tr>
<td style="text-align:left"><em>end</em></td>
<td style="text-align:left">可选。停止复制的索引位置 (默认为 <em>array</em>.length)。如果为负值，表示倒数。</td>
</tr>
</tbody>
</table>
<pre><code class="lang-javascript">const arr = [1, 2, 3, 4];
console.log(arr.copyWithin(2, 0, 2)); //[1, 2, 1, 2]
</code></pre>
<h3 id="-">查找元素</h3>
<h4 id="indexof">indexOf</h4>
<p>使用 <code>indexOf</code> 从前向后查找元素出现的位置，如果找不到返回 <code>-1</code>。</p>
<pre><code class="lang-javascript">let arr = [7, 3, 2, 8, 2, 6];
console.log(arr.indexOf(2)); // 2 从前面查找2出现的位置
</code></pre>
<p>如下面代码一下，使用 <code>indexOf</code> 查找字符串将找不到，因为<code>indexOf</code> 类似于<code>===</code>是严格类型约束。</p>
<pre><code class="lang-javascript">let arr = [7, 3, 2, &#39;8&#39;, 2, 6];
console.log(arr.indexOf(8)); // -1
</code></pre>
<p>第二个参数用于指定查找开始位置</p>
<pre><code class="lang-javascript">let arr = [7, 3, 2, 8, 2, 6];
//从第二个元素开始向后查找
console.log(arr.indexOf(2, 3)); //4
</code></pre>
<h4 id="lastindexof">lastIndexOf</h4>
<p>使用 <code>lastIndexOf</code> 从后向前查找元素出现的位置，如果找不到返回 <code>-1</code>。</p>
<pre><code class="lang-javascript">let arr = [7, 3, 2, 8, 2, 6];
console.log(arr.lastIndexOf(2)); // 4 从后查找2出现的位置
</code></pre>
<p>第二个参数用于指定查找开始位置</p>
<pre><code class="lang-javascript">let arr = [7, 3, 2, 8, 2, 6];
//从第五个元素向前查找
console.log(arr.lastIndexOf(2, 5));

//从最后一个字符向前查找
console.log(arr.lastIndexOf(2, -2));
</code></pre>
<h4 id="includes">includes</h4>
<p>使用 <code>includes</code> 查找字符串返回值是布尔类型更方便判断</p>
<pre><code class="lang-javascript">let arr = [7, 3, 2, 6];
console.log(arr.includes(6)); //true
</code></pre>
<p>我们来实现一个自已经的<code>includes</code>函数，来加深对<code>includes</code>方法的了解</p>
<pre><code class="lang-javascript">function includes(array, item) {
  for (const value of array)
    if (item === value) return true;
  return false;
}

console.log(includes([1, 2, 3, 4], 3)); //true
</code></pre>
<h4 id="find">find</h4>
<p>find 方法找到后会把值返回出来</p>
<ul>
<li>如果找不到返回值为<code>undefined</code></li>
</ul>
<p>返回第一次找到的值，不继续查找</p>
<pre><code class="lang-javascript">let arr = [&quot;hdcms&quot;, &quot;houdunren&quot;, &quot;hdcms&quot;];

let find = arr.find(function(item) {
  return item == &quot;hdcms&quot;;
});

console.log(find); //hdcms
</code></pre>
<p>使用<code>includes</code>等不能查找引用类型，因为它们的内存地址是不相等的</p>
<pre><code class="lang-javascript">const user = [{ name: &quot;李四&quot; }, { name: &quot;张三&quot; }, { name: &quot;后盾人&quot; }];
const find = user.includes({ name: &quot;后盾人&quot; });
console.log(find);
</code></pre>
<p><code>find</code> 可以方便的查找引用类型</p>
<pre><code class="lang-javascript">const user = [{ name: &quot;李四&quot; }, { name: &quot;张三&quot; }, { name: &quot;后盾人&quot; }];
const find = user.find(user =&gt; (user.name = &quot;后盾人&quot;));
console.log(find);
</code></pre>
<h4 id="findindex">findIndex</h4>
<p><code>findIndex</code> 与 <code>find</code> 的区别是返回索引值，参数也是 : 当前值，索引，操作数组。</p>
<ul>
<li>查找不到时返回 <code>-1</code></li>
</ul>
<pre><code class="lang-javascript">let arr = [7, 3, 2, &#39;8&#39;, 2, 6];

console.log(arr.findIndex(function (v) {
    return v == 8;
})); //3
</code></pre>
<h4 id="find-">find原理</h4>
<p>下面使用自定义函数</p>
<pre><code class="lang-javascript">let arr = [1, 2, 3, 4, 5];
function find(array, callback) {
  for (const value of array) {
    if (callback(value) === true) return value;
  }
  return undefined;
}
let res = find(arr, function(item) {
  return item == 23;
});
console.log(res);
</code></pre>
<p>下面添加原型方法实现</p>
<pre><code class="lang-javascript">Array.prototype.findValue = function(callback) {
  for (const value of this) {
    if (callback(value) === true) return value;
  }
  return undefined;
};

let re = arr.findValue(function(item) {
  return item == 2;
});
console.log(re);

</code></pre>
<h3 id="-">循环遍历</h3>
<h4 id="for">for</h4>
<p>根据数组长度结合<code>for</code> 循环来遍历数组</p>
<pre><code class="lang-text">let lessons = [
    {title: &#39;媒体查询响应式布局&#39;,category: &#39;css&#39;},
  {title: &#39;FLEX 弹性盒模型&#39;,category: &#39;css&#39;},
    {title: &#39;MYSQL多表查询随意操作&#39;,category: &#39;mysql&#39;}
];

for (let i = 0; i &lt; lessons.length; i++) {
  lessons[i] = `后盾人: ${lessons[i].title}`;
}
console.log(lessons);
</code></pre>
<h4 id="foreach">forEach</h4>
<p><code>forEach</code>使函数作用在每个数组元素上，但是没有返回值。</p>
<p>下面例子是截取标签的五个字符。</p>
<pre><code class="lang-text">let lessons = [
    {title: &#39;媒体查询响应式布局&#39;,category: &#39;css&#39;},
  {title: &#39;FLEX 弹性盒模型&#39;,category: &#39;css&#39;},
    {title: &#39;MYSQL多表查询随意操作&#39;,category: &#39;mysql&#39;}
];

lessons.forEach((item, index, array) =&gt; {
    item.title = item.title.substr(0, 5);
});
console.log(lessons);
</code></pre>
<h4 id="for-in">for/in</h4>
<p>遍历时的 key 值为数组的索引</p>
<pre><code class="lang-text">let lessons = [
    {title: &#39;媒体查询响应式布局&#39;,category: &#39;css&#39;},
  {title: &#39;FLEX 弹性盒模型&#39;,category: &#39;css&#39;},
    {title: &#39;MYSQL多表查询随意操作&#39;,category: &#39;mysql&#39;}
];

for (const key in lessons) {
    console.log(`标题: ${lessons[key].title}`);
}
</code></pre>
<h4 id="for-of">for/of</h4>
<p>与 <code>for/in</code> 不同的是 <code>for/of</code> 每次循环取其中的值而不是索引。</p>
<pre><code class="lang-javascript">let lessons = [
    {title: &#39;媒体查询响应式布局&#39;,category: &#39;css&#39;},
  {title: &#39;FLEX 弹性盒模型&#39;,category: &#39;css&#39;},
    {title: &#39;MYSQL多表查询随意操作&#39;,category: &#39;mysql&#39;}
];

for (const item of lessons) {
  console.log(`
    标题: ${item.title}
    栏目: ${item.category == &quot;css&quot; ? &quot;前端&quot; : &quot;数据库&quot;}
  `);
}
</code></pre>
<p>使用数组的迭代对象遍历获取索引与值（有关迭代器知识后面章节会讲到）</p>
<pre><code class="lang-js">const hd = [&#39;houdunren&#39;, &#39;hdcms&#39;];
const iterator = hd.entries();
console.log(iterator.next()); //value:{0:0,1:&#39;houdunren&#39;}
console.log(iterator.next()); //value:{0:1,1:&#39;hdcms&#39;}
</code></pre>
<p>这样就可以使用解构特性与 <code>for/of</code> 遍历并获取索引与值了</p>
<pre><code class="lang-javascript">const hd = [&quot;hdcms&quot;, &quot;houdunren&quot;];

for (const [key, value] of hd.entries()) {
  console.log(key, value); //这样就可以遍历了
}
</code></pre>
<p>取数组中的最大值</p>
<pre><code class="lang-js">function arrayMax(array) {
  let max = array[0];
  for (const elem of array) {
    max = max &gt; elem ? max : elem;
  }
  return max;
}

console.log(arrayMax([1, 3, 2, 9]));
</code></pre>
<h3 id="-">迭代器</h3>
<h4 id="keys">keys</h4>
<p>通过迭代对象获取索引</p>
<pre><code class="lang-javascript">const hd = [&quot;houdunren&quot;, &quot;hdcms&quot;];
const keys = hd.keys();
console.log(keys.next());
console.log(keys.next());
</code></pre>
<p>获取数组所有键</p>
<pre><code class="lang-javascript">&quot;use strict&quot;;
const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;后盾人&quot;];

for (const key of arr.keys()) {
  console.log(key);
}
</code></pre>
<p>使用while遍历</p>
<pre><code class="lang-javascript">let arr = [&quot;hdcms&quot;, &quot;houdunren&quot;];
while (({ value, done } = values.keys()) &amp;&amp; done === false) {
    console.log(value);
}
</code></pre>
<h4 id="values">values</h4>
<p>通过迭代对象获取值</p>
<pre><code class="lang-javascript">const hd = [&quot;houdunren&quot;, &quot;hdcms&quot;];
const values = hd.values();
console.log(values.next());
console.log(values.next());
console.log(values.next());
</code></pre>
<p>获取数组的所有值</p>
<pre><code class="lang-javascript">&quot;use strict&quot;;
const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;后盾人&quot;];

for (const value of arr.values()) {
  console.log(value);
}
</code></pre>
<h4 id="entries">entries</h4>
<p>返回数组所有键值对，下面使用解构语法循环</p>
<pre><code class="lang-javascript">const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;后盾人&quot;];
for (const [key, value] of arr.entries()) {
  console.log(key, value);
}
</code></pre>
<p>解构获取内容（对象章节会详细讲解）</p>
<pre><code class="lang-js">const hd = [&quot;houdunren&quot;, &quot;hdcms&quot;];
const iterator = hd.entries();

let {done,value: [k, v]} = iterator.next();

console.log(v);
</code></pre>
<h3 id="-">扩展方法</h3>
<h4 id="every">every</h4>
<p><code>every</code> 用于递归的检测元素，要所有元素操作都要返回真结果才为真。</p>
<p>查看班级中同学的JS成绩是否都及格</p>
<pre><code class="lang-js">const user = [
  { name: &quot;李四&quot;, js: 89 },
  { name: &quot;马六&quot;, js: 55 },
  { name: &quot;张三&quot;, js: 78 }
];
const resust = user.every(user =&gt; user.js &gt;= 60);
console.log(resust);
</code></pre>
<p>标题的关键词检查</p>
<pre><code class="lang-js">let words = [&#39;后盾&#39;, &#39;北京&#39;, &#39;培训&#39;];
let title = &#39;后盾人不断分享技术教程&#39;;

let state = words.every(function (item, index, array) {
  return title.indexOf(item) &gt;= 0;
});

if (state == false) console.log(&#39;标题必须包含所有关键词&#39;);
</code></pre>
<h4 id="some">some</h4>
<p>使用 <code>some</code> 函数可以递归的检测元素，如果有一个返回true，表达式结果就是真。第一个参数为元素，第二个参数为索引，第三个参数为原数组。</p>
<p>下面是使用 <code>some</code> 检测规则关键词的示例，如果匹配到一个词就提示违规。</p>
<pre><code class="lang-js">let words = [&#39;后盾&#39;, &#39;北京&#39;, &#39;武汉&#39;];
let title = &#39;后盾人不断分享技术教程&#39;

let state = words.some(function (item, index, array) {
    return title.indexOf(item) &gt;= 0;
});

if (state) console.log(&#39;标题含有违规关键词&#39;);
</code></pre>
<h4 id="filter">filter</h4>
<p>使用 <code>filter</code> 可以过滤数据中元素，下面是获取所有在CSS栏目的课程。</p>
<pre><code class="lang-js">let lessons = [
  {title: &#39;媒体查询响应式布局&#39;,category: &#39;css&#39;},
  {title: &#39;FLEX 弹性盒模型&#39;,category: &#39;css&#39;},
  {title: &#39;MYSQL多表查询随意操作&#39;,category: &#39;mysql&#39;}
];

let cssLessons = lessons.filter(function (item, index, array) {
  if (item.category.toLowerCase() == &#39;css&#39;) {
    return true;
  }
});

console.log(cssLessons);
</code></pre>
<p>我们来写一个过滤元素的方法来加深些技术</p>
<pre><code class="lang-js">function except(array, excepts) {
  const newArray = [];
  for (const elem of array)
    if (!excepts.includes(elem)) newArray.push(elem);
  return newArray;
}

const array = [1, 2, 3, 4];
console.log(except(array, [2, 3])); //[1,4]
</code></pre>
<p>map</p>
<p>map(function(value,index,arr)) 对数组进行二次操作。</p>
<h4 id="reduce">reduce</h4>
<p>使用 <code>reduce</code> 与 <code>reduceRight</code> 函数可以迭代数组的所有元素，<code>reduce</code> 从前开始 <code>reduceRight</code> 从后面开始。下面通过函数计算课程点击数的和。</p>
<p>第一个参数是执行函数，第二个参数为初始值</p>
<ul>
<li>传入第二个参数时将所有元素循环一遍</li>
<li>不传第二个参数时从第二个元素开始循环,不传入参数时prev第一次为数组第一个值，从第二次开始是函数的返回值</li>
</ul>
<p>函数参数说明如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>prev</td>
<td>上次调用回调函数返回的结果</td>
</tr>
<tr>
<td>cur</td>
<td>当前的元素值</td>
</tr>
<tr>
<td>index</td>
<td>当前的索引</td>
</tr>
<tr>
<td>array</td>
<td>原数组</td>
</tr>
</tbody>
</table>
<h2 id="symbol">symbol</h2>
<p>Symbol用于防止属性名冲突而产生的，比如向第三方对象中添加属性时。</p>
<p>Symbol 的值是唯一的，独一无二的不会重复的</p>
<h3 id="-">基础知识</h3>
<h4 id="symbol">Symbol</h4>
<pre><code class="lang-js">let hd = Symbol();
let edu = Symbol();
console.log(hd); //symbol
console.log(hd == edu); //false
</code></pre>
<p>Symbol 不可以添加属性</p>
<pre><code class="lang-js">let hd = Symbol();
hd.name = &quot;后盾人&quot;;
console.log(hd.name);
</code></pre>
<h4 id="-">描述参数</h4>
<p>可传入字符串用于描述Symbol，方便在控制台分辨Symbol</p>
<pre><code class="lang-js">let hd = Symbol(&quot;is name&quot;);
let edu = Symbol(&quot;这是一个测试&quot;);

console.log(hd); //Symbol(is name)
console.log(edu.toString()); //Symbol(这是一个测试)
</code></pre>
<p>传入相同参数Symbol也是独立唯一的，因为参数只是描述而已，但使用 <code>Symbol.for</code>则不会</p>
<pre><code class="lang-js">let hd = Symbol(&quot;后盾人&quot;);
let edu = Symbol(&quot;后盾人&quot;);
console.log(hd == edu); //false
</code></pre>
<p>使用<code>description</code>可以获取传入的描述参数</p>
<pre><code class="lang-js">let hd = Symbol(&quot;后盾人&quot;);
console.log(hd.description); //后盾人
</code></pre>
<h4 id="symbol-for">Symbol.for</h4>
<p>根据描述获取Symbol，如果不存在则新建一个Symbol</p>
<ul>
<li>使用Symbol.for会在系统中将Symbol登记</li>
<li>使用Symbol则不会登记</li>
</ul>
<pre><code class="lang-js">let hd = Symbol.for(&quot;后盾人&quot;);
let edu = Symbol.for(&quot;后盾人&quot;);
console.log(hd == edu); //true
</code></pre>
<h4 id="symbol-keyfor">Symbol.keyFor</h4>
<p><code>Symbol.keyFor</code> 根据使用<code>Symbol.for</code>登记的Symbol返回描述，如果找不到返回undefined 。</p>
<pre><code class="lang-js">let hd = Symbol.for(&quot;后盾人&quot;);
console.log(Symbol.keyFor(hd)); //后盾人

let edu = Symbol(&quot;houdunren&quot;);
console.log(Symbol.keyFor(edu)); //undefined
</code></pre>
<h4 id="-">对象属性</h4>
<p>Symbol 是独一无二的所以可以保证对象属性的唯一。</p>
<ul>
<li>Symbol 声明和访问使用 <code>[]</code>（变量）形式操作</li>
<li>也不能使用 <code>.</code> 语法因为 <code>.</code>语法是操作字符串属性的。</li>
</ul>
<p>下面写法是错误的，会将<code>symbol</code> 当成字符串<code>symbol</code>处理</p>
<pre><code class="lang-js">let symbol = Symbol(&quot;后盾人&quot;);
let obj = {
  symbol: &quot;hdcms.com&quot;
};
console.log(obj);
</code></pre>
<p>正确写法是以<code>[]</code> 变量形式声明和访问</p>
<pre><code class="lang-js">let symbol = Symbol(&quot;后盾人&quot;);
let obj = {
  [symbol]: &quot;houdunren.com&quot;
};
console.log(obj[symbol]); //houdunren.com
</code></pre>
<h3 id="-">实例操作</h3>
<h4 id="-">缓存操作</h4>
<p>使用<code>Symbol</code>可以解决在保存数据时由于名称相同造成的耦合覆盖问题。</p>
<pre><code class="lang-js">class Cache {
  static data = {};
  static set(name, value) {
    this.data[name] = value;
  }
  static get(name) {
    return this.data[name];
  }
}

let user = {
  name: &quot;后盾人&quot;,
  key: Symbol(&quot;缓存&quot;)
};

let cart = {
  name: &quot;购物车&quot;,
  key: Symbol(&quot;购物车&quot;)
};

Cache.set(user.key, user);
Cache.set(cart.key, cart);
console.log(Cache.get(user.key));
</code></pre>
<h4 id="-">遍历属性</h4>
<p>Symbol 不能使用 <code>for/in</code>、<code>for/of</code> 遍历操作</p>
<pre><code class="lang-js">let symbol = Symbol(&quot;后盾人&quot;);
let obj = {
  name: &quot;hdcms.com&quot;,
  [symbol]: &quot;houdunren.com&quot;
};

for (const key in obj) {
  console.log(key); //name
}

for (const key of Object.keys(obj)) {
  console.log(key); //name
}
</code></pre>
<p>可以使用 <code>Object.getOwnPropertySymbols</code> 获取所有<code>Symbol</code>属性</p>
<pre><code class="lang-js">...
for (const key of Object.getOwnPropertySymbols(obj)) {
  console.log(key);
}
</code></pre>
<p>也可以使用 <code>Reflect.ownKeys(obj)</code> 获取所有属性包括<code>Symbol</code></p>
<pre><code class="lang-js">...
for (const key of Reflect.ownKeys(obj)) {
  console.log(key);
}
...
</code></pre>
<p>如果对象属性不想被遍历，可以使用<code>Symbol</code>保护</p>
<pre><code class="lang-js">const site = Symbol(&quot;网站名称&quot;);
class User {
  constructor(name) {
    this[site] = &quot;后盾人&quot;;
    this.name = name;
  }
  getName() {
    return `${this[site]}-${this.name}`;
  }
}
const hd = new User(&quot;向军大叔&quot;);
console.log(hd.getName());
for (const key in hd) {
  console.log(key);
}
</code></pre>
<h2 id="set">set</h2>
<p>用于存储任何类型的唯一值，无论是基本类型还是对象引用。</p>
<ul>
<li>只能保存值没有键名</li>
<li>严格类型检测如字符串数字不等于数值型数字</li>
<li>值是唯一的</li>
<li>遍历顺序是添加的顺序，方便保存回调函数</li>
</ul>
<h3 id="-">基本使用</h3>
<p>对象可以属性最终都会转为字符串</p>
<pre><code class="lang-js">let obj = { 1: &quot;hdcms&quot;, &quot;1&quot;: &quot;houdunren&quot; };
console.table(obj); //{1:&quot;houdunren&quot;}
</code></pre>
<p>使用对象做为键名时，会将对象转为字符串后使用</p>
<pre><code class="lang-js">let obj = { 1: &quot;hdcms&quot;, &quot;1&quot;: &quot;houdunren&quot; };
console.table(obj);

let hd = { [obj]: &quot;后盾人&quot; };
console.table(hd);

console.log(hd[obj.toString()]);
console.log(hd[&quot;[object Object]&quot;]);
</code></pre>
<p>使用数组做初始数据</p>
<pre><code class="lang-js">let hd = new Set([&#39;后盾人&#39;, &#39;hdcms&#39;]);
console.log(hd.values()); //{&quot;后盾人&quot;, &quot;hdcms&quot;}
</code></pre>
<p>Set 中是严格类型约束的，下面的数值<code>1</code>与字符串<code>1</code>属于两个不同的值</p>
<pre><code class="lang-js">let set = new Set();
set.add(1);
set.add(&quot;1&quot;);
console.log(set); //Set(2) {1, &quot;1&quot;}
</code></pre>
<p>使用 <code>add</code> 添加元素，不允许重复添加<code>hdcms</code>值</p>
<pre><code class="lang-js">let hd = new Set();

hd.add(&#39;houdunren&#39;);
hd.add(&#39;hdcms&#39;);
hd.add(&#39;hdcms&#39;)

console.log(hd.values()); //SetIterator {&quot;houdunren&quot;, &quot;hdcms&quot;}
</code></pre>
<h3 id="-">获取数量</h3>
<p>获取元素数量</p>
<pre><code class="lang-js">let hd = new Set([&#39;后盾人&#39;, &#39;hdcms&#39;]);
console.log(hd.size); //2
</code></pre>
<h3 id="-">元素检测</h3>
<p>检测元素是否存在</p>
<pre><code class="lang-js">let hd = new Set();
hd.add(&#39;hdcms&#39;);
console.log(hd.has(&#39;hdcms&#39;));//true
</code></pre>
<h3 id="-">删除元素</h3>
<p>使用 <code>delete</code> 方法删除单个元素，返回值为<code>boolean</code>类型</p>
<pre><code class="lang-js">let hd = new Set();
hd.add(&quot;hdcms&quot;);
hd.add(&quot;houdunren&quot;);

console.log(hd.delete(&quot;hdcms&quot;)); //true

console.log(hd.values());
console.log(hd.has(&quot;hdcms&quot;)); //false
</code></pre>
<p>使用 <code>clear</code> 删除所有元素</p>
<pre><code class="lang-js">let hd = new Set();
hd.add(&#39;hdcms&#39;);
hd.add(&#39;houdunren&#39;);
hd.clear();
console.log(hd.values());
</code></pre>
<h3 id="-">数组转换</h3>
<p>可以使用<code>点语法</code> 或 <code>Array.form</code> 静态方法将Set类型转为数组，这样就可以使用数组处理函数了</p>
<pre><code class="lang-js">const set = new Set([&quot;hdcms&quot;, &quot;houdunren&quot;]);
console.log([...set]); //[&quot;hdcms&quot;, &quot;houdunren&quot;]
console.log(Array.from(set)); //[&quot;hdcms&quot;, &quot;houdunren&quot;]
</code></pre>
<p>移除Set中大于5的数值</p>
<pre><code class="lang-js">let hd = new Set(&quot;123456789&quot;);
hd = new Set([...hd].filter(item =&gt; item &lt; 5));
console.log(hd);
</code></pre>
<h3 id="-">去除重复</h3>
<p>去除字符串重复</p>
<pre><code class="lang-js">console.log([...new Set(&quot;houdunren&quot;)].join(&quot;&quot;));//houdnre
</code></pre>
<p>去除数组重复</p>
<pre><code class="lang-js">const arr = [1, 2, 3, 5, 2, 3];
console.log(...new Set(arr)); // 1,2,4,5
</code></pre>
<h3 id="-">遍历数据</h3>
<p>使用 <code>keys()/values()/entries()</code> 都可以返回迭代对象，因为<code>set</code>类型只有值所以 <code>keys与values</code> 方法结果一致。</p>
<pre><code class="lang-js">const hd = new Set([&quot;hdcms&quot;, &quot;houdunren&quot;]);
console.log(hd.values()); //SetIterator {&quot;hdcms&quot;, &quot;houdunren&quot;}
console.log(hd.keys()); //SetIterator {&quot;hdcms&quot;, &quot;houdunren&quot;}
console.log(hd.entries()); //SetIterator {&quot;hdcms&quot; =&gt; &quot;hdcms&quot;, &quot;houdunren&quot; =&gt; &quot;houdunren&quot;}
</code></pre>
<p>可以使用 <code>forEach</code> 遍历Set数据，默认使用 <code>values</code> 方法创建迭代器。</p>
<p>为了保持和遍历数组参数统一，函数中的value与key是一样的。</p>
<pre><code class="lang-js">let arr = [7, 6, 2, 8, 2, 6];
let set = new Set(arr);
//使用forEach遍历
set.forEach((item,key) =&gt; console.log(item,key));
</code></pre>
<p>也可以使用 <code>forof</code> 遍历Set数据，默认使用 <code>values</code> 方法创建迭代器</p>
<pre><code class="lang-js">//使用for/of遍历
let set = new Set([7, 6, 2, 8, 2, 6]);

for (const iterator of set) {
    console.log(iterator);
}
</code></pre>
<h2 id="weakset">weakSet</h2>
<p>WeakSet结构同样不会存储重复的值，它的成员必须只能是对象类型的值。</p>
<ul>
<li>垃圾回收不考虑WeakSet，即被WeakSet引用时引用计数器不加一，所以对象不被引用时不管WeakSet是否在使用都将删除</li>
<li>因为WeakSet 是弱引用，由于其他地方操作成员可能会不存在，所以不可以进行<code>forEach( )</code>遍历等操作</li>
<li>也是因为弱引用，WeakSet 结构没有keys( )，values( )，entries( )等方法和size属性</li>
<li>因为是弱引用所以当外部引用删除时，希望自动删除数据时使用 <code>WeakMap</code></li>
</ul>
<h3 id="-">声明定义</h3>
<p>以下操作由于数据不是对象类型将产生错误</p>
<pre><code class="lang-js">new WeakSet([&quot;hdcms&quot;, &quot;houdunren&quot;]); //Invalid value used in weak set

new WeakSet(&quot;hdcms&quot;); //Invalid value used in weak set
</code></pre>
<p>WeakSet的值必须为对象类型</p>
<pre><code class="lang-js">new WeakSet([[&quot;hdcms&quot;], [&quot;houdunren&quot;]]);
</code></pre>
<p>将DOM节点保存到<code>WeakSet</code></p>
<pre><code class="lang-js">document.querySelectorAll(&quot;button&quot;).forEach(item =&gt; Wset.add(item));
</code></pre>
<h3 id="-">基本操作</h3>
<p>下面是WeakSet的常用指令</p>
<pre><code class="lang-js">const hd = new WeakSet();
const arr = [&quot;hdcms&quot;];
//添加操作
hd.add(arr);
console.log(hd.has(arr));

//删除操作
hd.delete(arr);

//检索判断
console.log(hd.has(arr));
</code></pre>
<h3 id="-">垃圾回收</h3>
<p>WeaSet保存的对象不会增加引用计数器，如果一个对象不被引用了会自动删除。</p>
<ul>
<li>下例中的数组被 <code>arr</code> 引用了，引用计数器+1</li>
<li>数据又添加到了 hd 的WeaSet中，引用计数还是1</li>
<li>当 <code>arr</code> 设置为null时，引用计数-1 此时对象引用为0</li>
<li>当垃圾回收时对象被删除，这时WakeSet也就没有记录了</li>
</ul>
<pre><code class="lang-js">const hd = new WeakSet();
let arr = [&quot;hdcms&quot;];
hd.add(arr);
console.log(hd.has(arr));

arr = null;
console.log(hd); //WeakSet {Array(1)}

setTimeout(() =&gt; {
  console.log(hd); //WeakSet {}
}, 1000);
</code></pre>
<h2 id="bom">BOM</h2>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220314194412799.png" alt="image-20220314194412799"></p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220314194446140.png" alt="image-20220314194446140"></p>
<h2 id="dom">DOM</h2>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220314194610319.png" alt="image-20220314194610319"></p>
<h2 id="-">作用域</h2>
<p>var定义的作用域同java类似</p>
<h2 id="-">方法</h2>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220115152204588.png" alt="image-20220115152204588" style="zoom:50%;" /></p>
<p>this指向调用方法的对象，任何函数都有一个apply方法来修改this指向的对象</p>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220115152533411.png" alt="image-20220115152533411" style="zoom:50%;" /></p>
<h2 id="-">正则表达式</h2>
<h3 id="-">表达式全集</h3>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“<code>n</code>”匹配字符“<code>n</code>”。“<code>\n</code>”匹配一个换行符。串行“<code>\\</code>”匹配“<code>\</code>”而“<code>\(</code>”则匹配“<code>(</code>”。</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:left">匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<code>\n</code>”或“<code>\r</code>”之后的位置。</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:left">匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<code>\n</code>”或“<code>\r</code>”之前的位置。</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配“<code>z</code>”以及“<code>zoo</code>”。</em>等价于{0,}。</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，“<code>zo+</code>”能匹配“<code>zo</code>”以及“<code>zoo</code>”，但不能匹配“<code>z</code>”。+等价于{1,}。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，“<code>do(es)?</code>”可以匹配“<code>does</code>”或“<code>does</code>”中的“<code>do</code>”。?等价于{0,1}。</td>
</tr>
<tr>
<td style="text-align:center">{<em>n</em>}</td>
<td style="text-align:left"><em>n</em>是一个非负整数。匹配确定的<em>n</em>次。例如，“<code>o{2}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但是能匹配“<code>food</code>”中的两个o。</td>
</tr>
<tr>
<td style="text-align:center">{<em>n</em>,}</td>
<td style="text-align:left"><em>n</em>是一个非负整数。至少匹配<em>n</em>次。例如，“<code>o{2,}</code>”不能匹配“<code>Bob</code>”中的“<code>o</code>”，但能匹配“<code>foooood</code>”中的所有o。“<code>o{1,}</code>”等价于“<code>o+</code>”。“<code>o{0,}</code>”则等价于“<code>o*</code>”。</td>
</tr>
<tr>
<td style="text-align:center">{<em>n</em>,<em>m</em>}</td>
<td style="text-align:left"><em>m</em>和<em>n</em>均为非负整数，其中<em>n</em>&lt;=<em>m</em>。最少匹配<em>n</em>次且最多匹配<em>m</em>次。例如，“<code>o{1,3}</code>”将匹配“<code>fooooood</code>”中的前三个o。“<code>o{0,1}</code>”等价于“<code>o?</code>”。请注意在逗号和两个数之间不能有空格。</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:left">当该字符紧跟在任何一个其他限制符（<em>,+,?，{</em>n<em>}，{</em>n<em>,}，{</em>n<em>,</em>m*}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“<code>oooo</code>”，“<code>o+?</code>”将匹配单个“<code>o</code>”，而“<code>o+</code>”将匹配所有“<code>o</code>”。</td>
</tr>
<tr>
<td style="text-align:center">.</td>
<td style="text-align:left">匹配除“<code>\</code><em><code>n</code></em>”之外的任何单个字符。要匹配包括“<code>\</code><em><code>n</code></em>”在内的任何字符，请使用像“`(.</td>
<td>\n)`”的模式。</td>
</tr>
<tr>
<td style="text-align:center">(pattern)</td>
<td style="text-align:left">匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<code>\(</code>”或“<code>\)</code>”。</td>
</tr>
<tr>
<td style="text-align:center">(?:pattern)</td>
<td style="text-align:left">匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“`(</td>
<td>)<code>”来组合一个模式的各个部分是很有用。例如“</code>industr(?:y</td>
<td>ies)<code>”就是一个比“</code>industry</td>
<td>industries`”更简略的表达式。</td>
</tr>
<tr>
<td style="text-align:center">(?=pattern)</td>
<td style="text-align:left">正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“`Windows(?=95</td>
<td>98</td>
<td>NT</td>
<td>2000)<code>”能匹配“</code>Windows2000<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows3.1<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td>
</tr>
<tr>
<td style="text-align:center">(?!pattern)</td>
<td style="text-align:left">正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“`Windows(?!95</td>
<td>98</td>
<td>NT</td>
<td>2000)<code>”能匹配“</code>Windows3.1<code>”中的“</code>Windows<code>”，但不能匹配“</code>Windows2000<code>”中的“</code>Windows`”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;=pattern)</td>
<td style="text-align:left">反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“`(?&lt;=95</td>
<td>98</td>
<td>NT</td>
<td>2000)Windows<code>”能匹配“</code>2000Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>3.1Windows<code>”中的“</code>Windows`”。</td>
</tr>
<tr>
<td style="text-align:center">(?&lt;!pattern)</td>
<td style="text-align:left">反向否定预查，与正向否定预查类拟，只是方向相反。例如“`(?&lt;!95</td>
<td>98</td>
<td>NT</td>
<td>2000)Windows<code>”能匹配“</code>3.1Windows<code>”中的“</code>Windows<code>”，但不能匹配“</code>2000Windows<code>”中的“</code>Windows`”。</td>
</tr>
<tr>
<td style="text-align:center">x\</td>
<td style="text-align:left">y</td>
<td>匹配x或y。例如，“`z</td>
<td>food<code>”能匹配“</code>z<code>”或“</code>food<code>”。“</code>(z</td>
<td>f)ood<code>”则匹配“</code>zood<code>”或“</code>food`”。</td>
</tr>
<tr>
<td style="text-align:center">[xyz]</td>
<td style="text-align:left">字符集合。匹配所包含的任意一个字符。例如，“<code>[abc]</code>”可以匹配“<code>plain</code>”中的“<code>a</code>”。</td>
</tr>
<tr>
<td style="text-align:center">[^xyz]</td>
<td style="text-align:left">负值字符集合。匹配未包含的任意字符。例如，“<code>[^abc]</code>”可以匹配“<code>plain</code>”中的“<code>p</code>”。</td>
</tr>
<tr>
<td style="text-align:center">[a-z]</td>
<td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，“<code>[a-z]</code>”可以匹配“<code>a</code>”到“<code>z</code>”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td style="text-align:center">[^a-z]</td>
<td style="text-align:left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<code>[^a-z]</code>”可以匹配任何不在“<code>a</code>”到“<code>z</code>”范围内的任意字符。</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:left">匹配一个单词边界，也就是指单词和空格间的位置。例如，“<code>er\b</code>”可以匹配“<code>never</code>”中的“<code>er</code>”，但不能匹配“<code>verb</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td style="text-align:center">\B</td>
<td style="text-align:left">匹配非单词边界。“<code>er\B</code>”能匹配“<code>verb</code>”中的“<code>er</code>”，但不能匹配“<code>never</code>”中的“<code>er</code>”。</td>
</tr>
<tr>
<td style="text-align:center">\cx</td>
<td style="text-align:left">匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“<code>c</code>”字符。</td>
</tr>
<tr>
<td style="text-align:center">\d</td>
<td style="text-align:left">匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td style="text-align:center">\D</td>
<td style="text-align:left">匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:left">匹配一个换页符。等价于\x0c和\cL。</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:left">匹配一个换行符。等价于\x0a和\cJ。</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:left">匹配一个回车符。等价于\x0d和\cM。</td>
</tr>
<tr>
<td style="text-align:center">\s</td>
<td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:center">\S</td>
<td style="text-align:left">匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:left">匹配一个制表符。等价于\x09和\cI。</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:left">匹配一个垂直制表符。等价于\x0b和\cK。</td>
</tr>
<tr>
<td style="text-align:center">\w</td>
<td style="text-align:left">匹配包括下划线的任何单词字符。等价于“<code>[A-Za-z0-9_]</code>”。</td>
</tr>
<tr>
<td style="text-align:center">\W</td>
<td style="text-align:left">匹配任何非单词字符。等价于“<code>[^A-Za-z0-9_]</code>”。</td>
</tr>
<tr>
<td style="text-align:center">\x<em>n</em></td>
<td style="text-align:left">匹配<em>n</em>，其中<em>n</em>为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<code>\x41</code>”匹配“<code>A</code>”。“<code>\x041</code>”则等价于“<code>\x04&amp;1</code>”。正则表达式中可以使用ASCII编码。.</td>
</tr>
<tr>
<td style="text-align:center">*num*</td>
<td style="text-align:left">匹配<em>num</em>，其中<em>num</em>是一个正整数。对所获取的匹配的引用。例如，“<code>(.)\1</code>”匹配两个连续的相同字符。</td>
</tr>
<tr>
<td style="text-align:center">*n*</td>
<td style="text-align:left">标识一个八进制转义值或一个向后引用。如果*n<em>之前至少</em>n<em>个获取的子表达式，则</em>n<em>为向后引用。否则，如果</em>n<em>为八进制数字（0-7），则</em>n*为一个八进制转义值。</td>
</tr>
<tr>
<td style="text-align:center">*nm*</td>
<td style="text-align:left">标识一个八进制转义值或一个向后引用。如果*nm<em>之前至少有</em>nm<em>个获得子表达式，则</em>nm<em>为向后引用。如果\</em>nm<em>之前至少有</em>n<em>个获取，则</em>n<em>为一个后跟文字</em>m<em>的向后引用。如果前面的条件都不满足，若</em>n<em>和</em>m<em>均为八进制数字（0-7），则\</em>nm<em>将匹配八进制转义值</em>nm*。</td>
</tr>
<tr>
<td style="text-align:center">*nml*</td>
<td style="text-align:left">如果<em>n</em>为八进制数字（0-3），且<em>m和l</em>均为八进制数字（0-7），则匹配八进制转义值<em>nm</em>l。</td>
</tr>
<tr>
<td style="text-align:center">\u<em>n</em></td>
<td style="text-align:left">匹配<em>n</em>，其中<em>n</em>是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。</td>
</tr>
</tbody>
</table>
<h3 id="-">常用正则表达式</h3>
<table>
<thead>
<tr>
<th style="text-align:center">用户名</th>
<th style="text-align:left">/^[a-z0-9_-]{3,16}$/</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">密码</td>
<td style="text-align:left">/^[a-z0-9_-]{6,18}$/</td>
</tr>
<tr>
<td style="text-align:center">十六进制值</td>
<td style="text-align:left">/^#?([a-f0-9]{6}\</td>
<td>[a-f0-9]{3})$/</td>
</tr>
<tr>
<td style="text-align:center">电子邮箱</td>
<td style="text-align:left">/^([a-z0-9_.-]+)@([\da-z.-]+).([a-z.]{2,6})\$/                                                                                /^[a-z\d]+(.[a-z\d]+)*@(<a href="-[\da-z]">\da-z</a>?)+(.{1,2}[a-z]+)+$/</td>
</tr>
<tr>
<td style="text-align:center">URL</td>
<td style="text-align:left">/^(https?:\/\/)?([\da-z.-]+).([a-z.]{2,6})([\/\w .-]<em>)</em>\/?$/</td>
</tr>
<tr>
<td style="text-align:center">IP 地址</td>
<td style="text-align:left">/((2[0-4]\d\</td>
<td>25[0-5]\</td>
<td>[01]?\d\d?).){3}(2[0-4]\d\</td>
<td>25[0-5]\</td>
<td>[01]?\d\d?)/                                              /^(?:(?:25[0-5]\</td>
<td>2[0-4][0-9]\</td>
<td>[01]?[0-9][0-9]?).){3}(?:25[0-5]\</td>
<td>2[0-4][0-9]\</td>
<td>[01]?[0-9][0-9]?)$/</td>
</tr>
<tr>
<td style="text-align:center">HTML 标签</td>
<td style="text-align:left">/^&lt;([a-z]+)([^&lt;]+)<em>(?:&gt;(.</em>)&lt;\/\1&gt;\</td>
<td>\s+\/&gt;)$/</td>
</tr>
<tr>
<td style="text-align:center">删除代码\注释</td>
<td style="text-align:left">(?&lt;!http:\</td>
<td>\S)//.*$</td>
</tr>
<tr>
<td style="text-align:center">Unicode编码中的汉字范围</td>
<td style="text-align:left">/^[\u2E80-\u9FFF]+$/</td>
</tr>
</tbody>
</table>
<h2 id="jquery">jQuery</h2>
<p><img src="C:\Users\LN\AppData\Roaming\Typora\typora-user-images\image-20220116145243398.png" alt="image-20220116145243398"></p>
<p>需要引入</p>
<pre><code class="lang-html">&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>

<h3 id="-">选择器</h3>
<p>id选择器：$(#id名)</p>
<p>类选择器：$(.类名)</p>
<p>标签选择器：$(标签名)</p>
<p>name选择器：$(：name名)</p>
<h3 id="-">常用函数</h3>
<p>$(select).click()    鼠标点击</p>
<p>$(select).text()    文本内容 text无参数获取选择器的文本，有参数设置文本</p>
<p>$(select).html()    html内容 用法同上</p>
<p>$(select).val()    获取表单的内容 单选框多选框的赋值等 即value</p>
<p>$(select).attr()    设置获取属性的值    一个形参为获取该属性的值 两个为设置</p>
<p>$(select).prop()    同上</p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>