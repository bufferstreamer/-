

# mysql

## DDL(database define )

![image-20220310103408924](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310103408924.png)

![image-20220310103555288](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310103555288.png)

![image-20220310103629529](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310103629529.png)

![image-20220310104041910](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310104041910.png)

![image-20220310105424636](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310105424636.png)

## DML

![image-20220310112443392](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310112443392.png)

![image-20220310112917819](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310112917819.png)

![image-20220310112930104](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310112930104.png)

## DQL

![image-20220310113232060](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310113232060.png)

![image-20220310113602453](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310113602453.png)

![image-20220310113752671](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310113752671.png)

![image-20220310114206136](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310114206136.png)

![image-20220310114432195](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310114432195.png)

![image-20220310114715713](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310114715713.png)

![image-20220310115420665](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310115420665.png)

## 约束

![image-20220310120447090](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310120447090.png)

![image-20220310161118672](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310161118672.png)

## 多表查询

![image-20220310163742347](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310163742347.png)

![image-20220310164013426](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310164013426.png)

![image-20220310164343761](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310164343761.png)

## 事务

![image-20220310171440774](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310171440774.png)

![image-20220310172129577](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310172129577.png)

# JDBC



![image-20220310172932116](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310172932116.png)



![image-20220310204320401](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310204320401.png)



![image-20220311132146183](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220311132146183.png)

![image-20220310204945243](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220310204945243.png)



![image-20220311154908183](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220311154908183.png)

![image-20220311160035579](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220311160035579.png)

# 连接池

![image-20220311161306294](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220311161306294.png)

![image-20220311161440736](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220311161440736.png)

# Maven

![image-20220311204248262](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220311204248262.png)

# Web

![image-20220314211206377](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314211206377.png)

## HTTP

![](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314211716423.png)

![](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314212026254.png)

![image-20220314212322622](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314212322622.png)



## 响应状态码

![image-20220314220909324](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314220909324.png)



# **servlet**

![image-20220314223226441](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314223226441.png)

## 执行流程

![image-20220314225505802](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314225505802.png)

## 生命周期

![](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314225621218.png)

## 方法

![image-20220314230016868](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220314230016868.png)

## Servlet urlpatten

![image-20220318122214627](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318122214627.png)

![](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318122703062.png)

## xml版本servlet



​		![image-20211021223704800](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20211021223704800.png)

servlet-name为下文mapping提供 class为实现了servlet接口的类

![image-20211021223214132](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20211021223214132.png)

url表示请求路径 *是通配符 注意前面有**/** 	比如Localhost：8080/任意都进入该class类

url可以写成*.ln格式 此时没有**/**   任何前缀加.ln均可进入该webapp

# Request

![image-20220318124313056](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318124313056.png)

![image-20220318125007082](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318125007082.png)

![image-20220318154809694](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318154809694.png)

## 请求转发

![](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318155318684.png)



# Response

![image-20220318155542611](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318155542611.png)

## 重定向

![image-20220318155847429](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318155847429.png)

![image-20220318160357862](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318160357862.png)

![image-20220318200154947](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318200154947.png)



# **servletContext**

保存一些数据，全局唯一，可以使多个webapp之间进行数据交换
	 servletConetext中的方法
		 getServletContext


```java
public servletContext getServletContext();
```

​			

```java
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        String username = "LN" ;
        servletContext.setAttribute("username",username);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
```

首先将username放进servletcontext容器中 该容器在webapp初始化时就会创建一个，并且只有一个。

```java
public class GetServlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String userName = (String) context.getAttribute("username");
        resp.setContentType("text/html");
        resp.setCharacterEncoding("utf-8");
        PrintWriter writer = resp.getWriter();
        writer.print(("名字" + userName));
    }
}
```

然后在getservlet中取得该username并通过响应输出到页面中

需要配置相应的web.xml

```xml
<servlet>
  <servlet-name>hello</servlet-name>
  <servlet-class>dlut.ln.servlet.HelloServlet</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>hello</servlet-name>
  <url-pattern>/hello</url-pattern>
</servlet-mapping>
<servlet>
  <servlet-name>getServlet</servlet-name>
  <servlet-class>dlut.ln.servlet.GetServlet</servlet-class>
</servlet>
<servlet-mapping>
  <servlet-name>getServlet</servlet-name>
  <url-pattern>/getC</url-pattern>
</servlet-mapping>
```

此时通过/hello可将username放进servletContext中，通过/getC可将username输出到页面上

###  getInitParameter

可以获取Context的初始参数 该参数可以通过相应的set方法设置也可以在xml文件中设置

```xml
<context-param>
  <param-name>namespace</param-name>
  <param-value>1598627</param-value>
</context-param>
```

```java
ServletContext context = this.getServletContext();
String namespace = context.getInitParameter("namespace");
PrintWriter writer = resp.getWriter();
writer.print(namespace);
```

###  requestDispatch

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.getServletContext().getRequestDispatcher("getC").forward(req,resp);
}
```

getRequestDispatcher(String src) 将该页面指向String字符串的页面。

forward(Request req,Response resp)转发上述请求

###  properties资源文件

读取资源文件时，maven会将resources中的properties自动导出target文件夹下class类

java中的java类文件也会自动导出，但是java文件夹下的properties文件不会自动导出，需要在pom.xml文件中添加

```xml
<bulid>   
	<resources>
      <resource>
        <directory>src/main/java/dlut.ln.servlet</directory>
        <includes>
          <include>**/*.xml</include>
          <include>**/*.properties</include>
        </includes>
      </resource>	
    </resources>
</build>
```

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    InputStream resource = this.getServletContext().getResourceAsStream("/WEB-INF/classes/pp.properties");
    Properties prop = new Properties();
    prop.load(resource);
    String username = prop.getProperty("username");
    String password = prop.getProperty("password");
    resp.getWriter().print(username +":" + password);
}
```

网页显示结果为LN:1598627

##  HttpServletResponse

 web服务器接收到客户端的http的请求，分别创建一个request和response。

如果想要获取客户端的参数：找HttpServletRequest

想要给客户端一些信息响应：找HttpServletResonse

<h2>1、简单分类

向浏览器发送数据的方法

```java
public ServletOutputStream getOutputStream()//写流
public PrintWriter getWriter()//写中文
```

### 下载文件

1、获取要下载文件的路径

2、下载文件名

3、让浏览器支持下载东西

4、获取下载文件的输入流

5、使用OutputStream将文件通过response返回给客户端

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String path = "C:\\Users\\刘怼怼\\Desktop\\html\\xtx-pc-client\\images\\教育部学籍在线验证报告_刘楠.pdf";
    String filename = path.substring(path.lastIndexOf('\\') + 1);
    resp.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(filename,"utf-8"));
    resp.setCharacterEncoding("utf-8");
    ServletOutputStream outputStream = resp.getOutputStream();
    FileInputStream inputStream = new FileInputStream(path);

    byte[] bytes = new byte[1024];
    int len;
    while ((len = inputStream.read(bytes) )> 0){
        outputStream.write(bytes,0,len);
    }
    inputStream.close();
    outputStream.close();
}
```

### 生成验证码 

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    //浏览器三秒刷新一次
    resp.setHeader("refresh","3");
    //生成一个图片
    BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
    //得到图片画笔
    Graphics2D graphics2D = (Graphics2D) image.getGraphics();
    //设置背景颜色
    graphics2D.setColor(Color.white);
    //填充矩形
    graphics2D.fillRect(0,0,80,20);
    //设置字体颜色
    graphics2D.setColor(Color.blue);
    graphics2D.setFont(new Font(null,Font.BOLD,20) );
    graphics2D.drawString(getRandom(),0,20);
    resp.setContentType("image/jpeg");
    //不缓存
    resp.setDateHeader("expires",-1);
    resp.setHeader("cache-control","no-cache");
    resp.setHeader("pragma","no-cache");
    ImageIO.write(image,"jpg",resp.getOutputStream());
}//生成随机数
private String getRandom(){
    Random random = new Random();
    String str = random.nextInt(9999) + "";
    StringBuffer stringBuffer = new StringBuffer();
    //保证随机数位数为4
    for (int i = 0; i < 4 - str.length(); i++){
        stringBuffer.append("0");
    }
    return stringBuffer.append(str).toString() ;
}
```

### **重定向**

![image-20211024104638097](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20211024104638097.png)

B收到A得请求会告诉A去找C		url会改变

常见场景：

​	用户登录

```java
public void sendRedirect(String location)
```

## HttpServletRequest

 HttpServletRequest代表客户端的请求，用户通过http访问服务器，通过request的方法可以得到客户端的所有信息。

### 请求转发

B收到A得请求自己去找C并且将C得结果返回给A	url不会改变

```java
public RequestDispatcher getRequestDispatcher(String path)
```

```jsp
									<%--index界面--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<body>
<h2>Hello World!</h2>
<form action="${pageContext.request.contextPath}/log" method="post">
    用户名：<input type="text" name="username"><br>
    密码：<input type="text" name="password"><br>
    爱好：
    <input type="checkbox" name="hobby" value="电影">电影
    <input type="checkbox" name="hobby" value="唱歌">唱歌
    <input type="submit">
</form>
</body>
</html>
```

```xml
								<!--  注册request-->
  <servlet>
    <servlet-name>login</servlet-name>
    <servlet-class>dlut.ln.servlet.Request</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>login</servlet-name>
    <url-pattern>/log</url-pattern>
  </servlet-mapping>
```

```JAVA
								//dlut.ln.servlet.Request类
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    req.setCharacterEncoding("utf-8");
    resp.setCharacterEncoding("utf-8");
    String username = req.getParameter("username");
    String password = req.getParameter("password");
    String[] hobbies = req.getParameterValues("hobby");
    System.out.println("username:" + username);
    System.out.println("password:" + password);
    System.out.println(Arrays.toString(hobbies));
    System.out.println(req.getContextPath());
     
    //"/"会被识别为当前web应用  不加/得时候会默认补上
    req.getRequestDispatcher("/success.jsp").forward(req,resp);
    //重定向时不能加/ 或者前面加上/r  r为部署tomcat服务器时定义的项目名称
    resp.sendRedirect("/r/success.jsp");
    /*
    重定向
    i:相对路径：response.sendRedirect("success.jsp")，容器相对于原来请求URL的目录加参数来生成完整的URL——http://localhost/r/success.jsp
   ii:绝对路径：response.sendRedirect("/success.jsp"),容器相对于Web应用本身加参数建立完整的URL，这是因为 重定向response.sendRedirect("")是服务器向客户端发送一个请求头信息,由客户端再请求一次服务器，请求是在服务器外进行的，即完整的url是——http://localhost/success.jsp
    iii:其它Web应用：response.sendRedirect("http://www.xxx.com")容器直接定向到该URL。
    请求转发
   i:相对路径情况下生成的完整URL与重定向方法相同。
   ii:绝对路径与Servlet重定向不同，容器将相对于Web应用的根目录加参数生成完整的URL（即“/”根路径就是相对于虚拟路径）这是因为转发是在服务器内部进行的,写绝对路径/开头指的是当前的Web应用程序。即：
request.getRequestDispatcher("/success.jsp")生成的URL是http://localhost/r/success.jsp。
  */
这里建议重定向时从/项目名称 开始写，该路径默认为web文件夹，如果只有/则会默认为http://localhost:8080/success.jsp
```

```JSP
						<%--点击提交按钮后跳转得页面--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>

<head>
    <title>SUCCESSFUL</title>
</head>

<body>

<h1>SUCCESSFUL</h1>

</body>
</html>
```


过程为首先进入index界面 点击提交后得action是跳转到注册得log类——即request，执行结束后请求转发至success.jsp 显示SUCCESSFUL

# Cookie、Session

##  会话

![](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318210236395.png)

打开浏览器，做了一些事，关闭浏览器，这个过程称为会话

客户端初次访问时服务器给客户端发送一个cookie，当客户端再次访问时，只需要检查cookie就不用再登录信息。类似于学校发给学生的学生证。

服务器内部记录客户端访问过，生成一个session，下次访问同样不在检查。类似于老师手里的学生名册。

##  保存会话的两种技术

### cookie

客户端技术（通过响应发送给客户端，通过请求使服务器可以检查）

### session

服务器技术（可以保存用户的会话信息，并放在session中）

##  cookie

![image-20220318210617151](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318210617151.png)

从请求中拿到cookie信息

服务器响应给客户端

```java
Cookie[] cookies = req.getCookies();//获得cookie
cookies.getName();//获得cookie名字
cookie.getValues();//获得cookie值
new cookie("lastLoginTime",System.currentTimeMillis() + "")//新建一个cookie
resp.addCookie();//添加cookie
cookie.setMaxAge//设置cookie有效期
```

![image-20220318211056272](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318211056272.png)

![image-20220318211631145](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318211631145.png)

##  session（重点）

![image-20220318211813245](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318211813245.png)

![image-20220318212224213](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318212224213.png)

![image-20220318212649758](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318212649758.png)



服务器会给每个用户（浏览器）创建一个session

一个session独占一个浏览器，只要浏览器不关闭，session就一直存在

**session和cookie的区别**

​	cookie是把用户数据写给浏览器，可以保存多个

​	session是把用户数据写给服务器，服务端保存

​	创建session

```java
 protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //解决乱码
//        req.setCharacterEncoding("utf-8");
//        resp.setCharacterEncoding("utf-8");
        resp.setContentType("text/html;charset = utf-8");//在内部调用了上面的代码 并且必须使用在对对象操作之前
        //得到session
        HttpSession session = req.getSession();
        //给session存东西
        session.setAttribute("LN","nice");
        //获得sessionId
        String id = session.getId();

        //判断是不是新创建
        if (session.isNew()){
            System.out.println("是新创建的SESSION");
            resp.getWriter().write("是新创建的SESSION");
        }else {
            System.out.println("没有新创建 原有sessionID：" + id);
            resp.getWriter().write("没有新创建 原有sessionID：" + id);

        }
```

获得session的value

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    HttpSession session = req.getSession();
    resp.setContentType("text/html;charset = utf-8");
    resp.getWriter().write((String) session.getAttribute("LN"));
}
```

注销session

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

    //得到session
    HttpSession session = req.getSession();

    //去除属性
    session.removeAttribute("LN");
    session.invalidate();//注销session

}
```

同时在xml中配置自动注销的时间

```xml
<session-config>
    <session-timeout>1</session-timeout>
</session-config>
```

#  JSP

java server pages:java服务端界面，同servlet，用于动态web技术

JSP本质上是一个servlet,jsp文件会生成一个java文件，里面的内容都放在该java文件的service方法中。

该类实现了JavaBase类 JavaBase继承了HttpServlet![image-20220318202513748](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318202513748.png)



##  基础语法

### jsp表达式

<%= java的所有语法%>

如：

```jsp
<%= new java.util.Date()%>
```

### jsp脚本片段

![image-20220318203138033](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318203138033.png)



<% java代码 %>

如：

```jsp
<%
	int sum = 0;
	for(int i = 0; i < 10; i++)
        sum += i;
	System out println(sum);
%>
```

### jsp声明

<%! java代码 %>

声明会被编译在jsp生成的java文件的类中，而<%= %>会被声称在该java文件的一个方法中

### jsp指令

```jsp
<%@page errorpage = "500.jsp"%>
```

当当前页面出现错误后会跳转到500.jsp文件，可以在该文件中定义错误界面

同时可以在xml文件中定义出错的处理

```xml
<error-page>
        <error-code>404</error-code>
        <location>/500.jsp</location>
    </error-page>
```



```jsp
<%@include file="500.jsp" %>
```

会将两个页面合二为一

```jsp
<jsp:include page="500.jsp">
  <h1>书写内容</h1>
</jsp:include>
```

将两个页面拼接在一起，但是还是两个页面（比较常用）

### JSP标签、JSTL标签、EL表达式

```xml
<dependency>
    <groupId>javax.servlet.jsp.jstl</groupId>
    <artifactId>jstl-api</artifactId>
    <version>1.2</version>
</dependency>

<dependency>
    <groupId>taglibs</groupId>
    <artifactId>standard</artifactId>
    <version>1.1.2</version>
</dependency>
```

需要导包

#### EL表达式：

![image-20220318203736609](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318203736609.png)

${ }

​	获取数据

​	执行运算

​	获得web的常用对象

#### JSP标签

```xml
<jsp:include></jsp:include>等
```

#### JSTL表达式

自定义的供我们使用的标签，作用和java代码一样

![image-20220318204553720](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318204553720.png)



## JavaBean

一个实体类：

​	必须有无参构造

​	属性必须私有化

​	必须有get/set方法

一般用来和数据库的字段做ORM映射

ORM:对象关系映射

​	数据库表-->类

​	字段（列）-->属性

​	行记录    -->对象

#  MVC架构

![image-20220318205032889](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318205032889.png)

![](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220318205243623.png)





![image-20211026153400190](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20211026153400190.png)

#  Filter（重点）

1、添加依赖

```xml
   <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet.jsp</groupId>
            <artifactId>javax.servlet.jsp-api</artifactId>
            <version>2.3.3</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet.jsp.jstl</groupId>
            <artifactId>jstl-api</artifactId>
            <version>1.2-rev-1</version>
        </dependency>

        <dependency>
            <groupId>taglibs</groupId>
            <artifactId>standard</artifactId>
            <version>1.1.2</version>
        </dependency>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.47</version>
        </dependency>
```



2、实现接口

```java
import javax.servlet.*;
import java.io.IOException;

public class Filter implements javax.servlet.Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
     response.setContentType("text/html;charset=utf-8");
        chain.doFilter(request,response);
    }

    @Override
    public void destroy() {

    }
}
```

3、在web.xml中添加过滤器

```xml
 <servlet>
        <servlet-name>showServlet</servlet-name>
        <servlet-class>MyServlet.Servlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>showServlet</servlet-name>
        <url-pattern>/servlet/show</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>showServlet</servlet-name>
        <url-pattern>/show</url-pattern>
    </servlet-mapping>

    <filter>
        <filter-name>filter</filter-name>
        <filter-class>MyFilter.Filt</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>filter</filter-name>
        <url-pattern>/servlet/*</url-pattern>
    </filter-mapping>
```

添加过滤器后服务器总是报错,将iml文件中的如下代码删除后恢复正常

```xml
<component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$" />
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
```

# Listener

实现一个监听器的接口

```java
public class Listener implements HttpSessionListener {
    @Override
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext servletContext = se.getSession().getServletContext();
        Integer number = (Integer) servletContext.getAttribute("number");
        if (number == null){
            number = 1;
        }
        else {
            number++;
        }
        servletContext.setAttribute("number",number);
    }

    @Override
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext servletContext = se.getSession().getServletContext();
        Integer number = (Integer) servletContext.getAttribute("number");
        if (number == null){
            number = 0;
        }
        else {
            number--;
        }
        servletContext.setAttribute("number",number);
    }
}
```

注册监听器

```xml
<listener>
    <listener-class>MyListener.Listener</listener-class>
</listener>
```

# AJAX

![image-20220319200317180](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220319200317180.png)

## 同步异步

![image-20220319200606181](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220319200606181.png)

## Axios

![image-20220319205126410](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220319205126410.png)

# JSON

![image-20220319205719317](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220319205719317.png)

## json 与 java bean转换

![image-20220319205904242](C:\Users\刘怼怼\AppData\Roaming\Typora\typora-user-images\image-20220319205904242.png)

 
